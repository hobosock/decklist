use std::{error::Error, fs::File};

use csv::ReaderBuilder;
use serde::Deserialize;

/// simple card format for collections and decklists
/// just the card name and the quantity
#[derive(Deserialize, Clone)]
pub struct CollectionCard {
    #[serde(rename = "Name")]
    pub name: String,
    #[serde(rename = "Count")]
    pub quantity: u64,
}

/// reads in Moxfield collection CSV and turns it into a Vec<CollectionCard>
pub fn read_moxfield_collection(file_name: String) -> Result<Vec<CollectionCard>, Box<dyn Error>> {
    let file = File::open(file_name)?;
    let mut reader = ReaderBuilder::new()
        .has_headers(true)
        .delimiter(b',')
        .from_reader(file);
    let mut iter = reader.deserialize();
    let mut collection = Vec::new();
    if let Some(result) = iter.next() {
        let record: CollectionCard = result?;
        collection.push(record);
    }
    Ok(collection)
}

/// Moxfield collection treats different printings of the same card as individual line items, but
/// that's not a distinction we need for this program.  This function "squashes" the quantities of
/// all printings of the same card into a single line item.
fn squash_collection(collection_in: Vec<CollectionCard>) -> Vec<CollectionCard> {
    let mut collection_out: Vec<CollectionCard> = Vec::new();
    for card in collection_in.iter() {
        if collection_out.len() > 0 {
            // check if name already exists
            let mut matched = false;
            for (i, squashed) in collection_out..iter().enumerate() {
                if card.name == squashed.name {
                    matched = true;
                    collection_out[i].quantity += card.quantity;
                }
            }
            if !matched {
                collection_out.push(card.clone());
            }
        } else {
            // go ahead and copy it over
            collection_out.push(card.clone());
        }
    }
    collection_out
}
